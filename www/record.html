<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<style type="text/css">
	body{
		margin: 0px;
		padding: 0px;
	}
	#wave{
		position: relative;
		background: rgba(2,34,3,0.8);
		width: 100%;
		overflow-x:scroll; 
	}
	#selector{
		background: red;
		height: 100%;
		width: 1px;
		display: inline-block;
		position: absolute;
	}
	#line{
		height: 100%;
		width: 1px;
		display: inline-block;
		position: absolute;
		background: yellow;
	}
	canvas{
		position: relative;
	}
</style>
<body>
	<button id="record">Record</button>
	<button id="stopRecord">Stop</button>
	<button id="playRecord">Play</button>
	<button id="cut">Cut</button>
	<script type="text/javascript">
		window.AudioContext = window.AudioContext ||
                      window.webkitAudioContext;

		var audioCtx = new AudioContext();
		var ctx=canvas.getContext("2d");
		
		var scriptNode;
		navigator.getUserMedia = navigator.getUserMedia ||
                         navigator.webkitGetUserMedia ||
                         navigator.mozGetUserMedia;

        canvas.setAttribute('width',wave.clientWidth);

        var streamRecord;
        var microphone;
        var recordBuffer;
        var idPlayInterval;

        var buffers=[];
        var data;
        var arrayData=new Float32Array(0);
        var startSong=0;
        var stopSong=0;
        var playStart=0;
        var recorToPlay;
        var playing=false;

        function startRecord(stream){
        	streamRecord=stream.getAudioTracks()[0];
        	microphone = audioCtx.createMediaStreamSource(stream);
			scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);
			microphone.connect(scriptNode);
			scriptNode.connect(audioCtx.destination);
			arrayData=new Float32Array();
			

			scriptNode.onaudioprocess=function(e){
				// console.log(e);
				buffers.push(e.inputBuffer.getChannelData(0));
				data=e.inputBuffer.getChannelData(0);

				buffers.push(data);

				var length=arrayData.length;
				var newLength=length+data.length;
				var newArray=new Float32Array(newLength);

				newArray.set(arrayData,0);
				newArray.set(data,length);
				arrayData=newArray;

			}
			

        }
		record.onclick=function(){

			navigator.getUserMedia({audio: true},startRecord,
			function(error){
				console.log(error);
			});
		}
		stopRecord.onclick=function(){

			streamRecord.stop();
			microphone.disconnect();
			scriptNode.disconnect();

			recordBuffer = audioCtx.createBuffer(1, arrayData.length, audioCtx.sampleRate);
		    output = recordBuffer.getChannelData(0);
			for (var i = 0; i < arrayData.length; i++) {
			    output[i] = arrayData[i];
			}

			drawData(recordBuffer);

		}

		playRecord.onmousedown=function(){


				if(playing==true){
					recorToPlay.stop();
					clearInterval(idPlayInterval);
				}
				else{
					recorToPlay = audioCtx.createBufferSource();
					recorToPlay.buffer = recordBuffer;
					recorToPlay.start(0);
					playStart=audioCtx.currentTime;
					playing=true;
					
					idPlayInterval=setInterval(function() {
						var timeInPx = getXOnSong(audioCtx.currentTime-playStart);
						// console.log(timeInPx);
						line.style.left=timeInPx+"px";
					},1);


					recorToPlay.onended=function () {
						// console.log(idPlayInterval);
						clearInterval(idPlayInterval);
						playing=false;
						
					}

					recorToPlay.connect(audioCtx.destination);
					// drawData(recordBuffer);
				}
			

			
		}

		function drawData(recordBuffer){
			var binSize = ( recordBuffer.duration * recordBuffer.sampleRate ) / canvas.width;
		    ctx.clearRect(0,0,canvas.width,canvas.height);
		    ctx.beginPath();
		    
		    var linePosition=10;
		    ctx.moveTo(0,canvas.height-linePosition);



		    var data=recordBuffer.getChannelData(0);
		    var xOnCanvas=0;
		    // console.log(binSize);
		    for (var i=0,len=data.length; i<len; i+=binSize) 
		    {
		      //avec la moyenne
		      // var tempdata=data.subarray(i,i+binSize);
		      // ctx.lineTo(xOnCanvas,canvas.height-Math.abs(Math.max.apply(Math, tempdata) * canvas.height/1.3)-linePosition);
		       
		       //sans la moyenne
		      var tempdata=data.subarray(i,i+binSize)[0];
		      ctx.lineTo(xOnCanvas,canvas.height-Math.abs(tempdata * canvas.height/1.1)-linePosition);

		      xOnCanvas++;
		    }
		    ctx.lineTo(canvas.width,canvas.height-linePosition);
		    ctx.closePath();
		    ctx.fill();
		    ctx.beginPath();
		    ctx.moveTo(0,canvas.height-linePosition);
		    ctx.lineTo(canvas.width,canvas.height-linePosition);
		    ctx.closePath();
		    ctx.stroke();
		}
		wave.onmousedown=function(event){
			var x=event.clientX-this.offsetLeft;
			startSong=x;
		}
		wave.onmousemove=function(event){
			if(event.buttons==1){
				var x=event.clientX-this.offsetLeft;
				stopSong=x;
				// console.log("start",getPositionOnSong(startSong));
				// console.log("stop",getPositionOnSong(stopSong));
				drawSelector();
			}

		}

		function drawSelector(){
			var left=Math.min(startSong,stopSong);
			var width=Math.abs(startSong-stopSong);
			selector.style.left=left+"px";
			selector.style.width=width+"px";
		}


		cut.onclick=function(){
			cutRecord();
		}

		function getPositionOnSong(x){
			var pxInSecond=recordBuffer.duration/canvas.width;
			/*console.log(x,"x");
			console.log(pxInSecond,"ratio");
			console.log(x*pxInSecond,'result');*/
			return x*pxInSecond;
		}

		function getXOnSong(sec){
			var pxInSecond=recordBuffer.duration/canvas.width;
			/*console.log(x,"x");
			console.log(pxInSecond,"ratio");
			console.log(x*pxInSecond,'result');*/
			return sec/pxInSecond;
		}

		function cutRecord(){
 			// console.log(recordBuffer);

 			var startPos=getPositionOnSong(Math.min(startSong,stopSong));
 			var stopPos=getPositionOnSong(Math.max(startSong,stopSong));
 			var duration=Math.abs(startPos-stopPos);
 			console.log(startPos,stopPos);

			var channels = recordBuffer.numberOfChannels;
			var frameCount = recordBuffer.sampleRate * duration;
			var frameStart = recordBuffer.sampleRate * startPos;
			var frameEnd = recordBuffer.sampleRate * stopPos;


			var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, recordBuffer.sampleRate);

			for (var channel = 0; channel < channels; channel++) {
			  var nowBuffering = myArrayBuffer.getChannelData(channel);
			  var pos=0;
			  for (var i = Math.round(frameStart); i < Math.round(frameEnd); i++) {
			    nowBuffering[pos] = recordBuffer.getChannelData(channel)[i];
			    pos++;
			  }
			}
			recordBuffer=myArrayBuffer;
			
			var recorToPlay = audioCtx.createBufferSource();
			recorToPlay.buffer = recordBuffer;
			recorToPlay.start(0);

			recorToPlay.connect(audioCtx.destination);
			drawData(recordBuffer);
		
		}
		
	</script>
</body>
</html>